
#include <WiFi.h>
#include <WiFiServer.h>
#include <ESPmDNS.h>

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#include <stdbool.h>
#include <stdint.h>

#include "nvs.h"
#include "nvs_flash.h"

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "esp_log.h"
#include "esp_bt.h"
#include "esp_bt_main.h"
#include "esp_gap_bt_api.h"
#include "esp_bt_device.h"
#include "esp_spp_api.h"

#include "wifi_password.h"


// OLED FeatherWing buttons map to different pins depending on board:
#if defined(ESP8266)
  #define BUTTON_A  0
  #define BUTTON_B 16
  #define BUTTON_C  2
#elif defined(ESP32)
  #define BUTTON_A 15
  #define BUTTON_B 32
  #define BUTTON_C 14
#elif defined(ARDUINO_STM32_FEATHER)
  #define BUTTON_A PA15
  #define BUTTON_B PC7
  #define BUTTON_C PC5
#elif defined(TEENSYDUINO)
  #define BUTTON_A  4
  #define BUTTON_B  3
  #define BUTTON_C  8
#elif defined(ARDUINO_FEATHER52832)
  #define BUTTON_A 31
  #define BUTTON_B 30
  #define BUTTON_C 27
#else // 32u4, M0, M4, nrf52840 and 328p
  #define BUTTON_A  9
  #define BUTTON_B  6
  #define BUTTON_C  5
#endif




/*static const uint8_t PROGMEM s_folabs_logo_inverted[] =
  {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x01, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x66, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xe7, 0x9f,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf3, 0xe7, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xe3, 0xef, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xc3, 0xef,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xef, 0x81, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xee, 0x01, 0xc0, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0x46, 0x77,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xcc, 0xc9, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xee, 0x0d, 0x01, 0xbf, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x03, 0x67,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0x83, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xc7, 0xdf, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xcf, 0xbf,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfc, 0xef, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
  };
*/

static const uint8_t PROGMEM s_folabs_logo[] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x20, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x30, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x08, 0x38, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x7c, 0x10, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xfc, 0x98,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x11, 0xf2, 0xfe, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x36, 0xf8, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xb9, 0x88,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x11, 0xfe, 0x3f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x7e, 0x08, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x3c, 0x10,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x08, 0x1c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x20, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x18, 0x60,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x03, 0x99, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x08, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};





static const char*    ssid     = STASSID;
static const char*    password = STAPSK;

#define KISS_PORT   8001
#define DEVICE_NAME "Far-Out-Labs"
 
static const  esp_spp_mode_t esp_spp_mode  =  ESP_SPP_MODE_CB ; 
static const  esp_spp_sec_t  sec_mask      =  ESP_SPP_SEC_AUTHENTICATE ; 
static const  esp_spp_role_t role_master   =  ESP_SPP_ROLE_MASTER ;

static  uint8_t        s_peer_bdname_len; 
static  char           s_peer_bdname[ ESP_BT_GAP_MAX_BDNAME_LEN  +  1 ]; 
static  esp_bd_addr_t  s_peer_bd_addr  =  { 0x04 , 0xEE , 0x03 , 0x9F , 0xB0 , 0x8C };

static const  esp_bt_inq_mode_t  s_inq_mode     = ESP_BT_INQ_MODE_GENERAL_INQUIRY; 
static const  uint8_t            s_inq_len      = 30; 
static const  uint8_t            s_inq_num_rsps = 0;


static WiFiClient* s_currentClient = NULL; // we only support one client at the moment (which is fine for this project)

WiFiServer       wifiServer( KISS_PORT );
Adafruit_SSD1306 display = Adafruit_SSD1306( 128, 32, &Wire );

void printStatusMessage( const char* msg, bool showLogo = false );


bool get_name_from_eir( uint8_t* eir, char* bdname, uint8_t* bdname_len ) 
{ 
    uint8_t* rmt_bdname =  NULL; 
    uint8_t  rmt_bdname_len  =  0 ;

    if( !eir )  
        return  false ; 
   
    rmt_bdname = esp_bt_gap_resolve_eir_data( eir, ESP_BT_EIR_TYPE_CMPL_LOCAL_NAME,  &rmt_bdname_len ); 
    if( ! rmt_bdname )
        rmt_bdname = esp_bt_gap_resolve_eir_data( eir, ESP_BT_EIR_TYPE_SHORT_LOCAL_NAME, &rmt_bdname_len ); 
    

    if( rmt_bdname )  
    { 
        if( rmt_bdname_len > ESP_BT_GAP_MAX_BDNAME_LEN )  
            rmt_bdname_len = ESP_BT_GAP_MAX_BDNAME_LEN; 

        if( bdname )  
        { 
            memcpy ( bdname,  rmt_bdname,  rmt_bdname_len ); 
            bdname[rmt_bdname_len] = '\0'; 
        } 
        
        if( bdname_len ) 
            *bdname_len = rmt_bdname_len; 
        
        return true; 
    }

    return false; 
}


static void esp_spp_cb(esp_spp_cb_event_t event, esp_spp_cb_param_t *param)
{
    char buf[1024];
    char spp_data[256];
    
    switch( event ) 
    {
      case ESP_SPP_INIT_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_INIT_EVT");
          esp_bt_dev_set_device_name( DEVICE_NAME );
          esp_bt_gap_set_scan_mode( ESP_BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE );
          esp_bt_gap_start_discovery( s_inq_mode , s_inq_len, s_inq_num_rsps );
          break;
          
      case ESP_SPP_DISCOVERY_COMP_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_DISCOVERY_COMP_EVT");
          if( param->disc_comp.status == ESP_SPP_SUCCESS )   
              esp_spp_connect( sec_mask,  role_master, param->disc_comp.scn[0], s_peer_bd_addr ); 
          break;
          
      case ESP_SPP_OPEN_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_OPEN_EVT");
          break;
      case ESP_SPP_CLOSE_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_CLOSE_EVT");
          break;
      case ESP_SPP_START_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_START_EVT");
          break;
      case ESP_SPP_CL_INIT_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_CL_INIT_EVT");
          break;
      case ESP_SPP_DATA_IND_EVT:
  //        if (param->data_ind.len < 1023) {
  //            snprintf(buf, (size_t)param->data_ind.len, (char *)param->data_ind.data);
  //            printf("%s\n", buf);
  //            sprintf(spp_data, "Receined characters: %d\n", param->data_ind.len);
  //            esp_spp_write(param->write.handle, strlen(spp_data), (uint8_t *)spp_data);
  //        }
  //        else {
  //            esp_log_buffer_hex("",param->data_ind.data,param->data_ind.len);
  //        }
  
            ESP_LOGI(SPP_TAG, "ESP_SPP_DATA_IND_EVT len=%d handle=%d", param->data_ind.len, param->data_ind.handle);
            
  //          for( int i = 0; i < param->data_ind.len; i++ ) 
  //          { 
  //              if( param->data_ind.data[i] == '\r' || param->data_ind.data[i] == '\n' )  
  //                Serial.print( "<n>" ); 
  //              else 
  //              {
  //                if( param->data_ind.data[i] >= 32 && param->data_ind.data[i] <= 126 )
  //                  Serial.print( (char)param->data_ind.data[i] ); 
  //                else
  //                  Serial.print( param->data_ind.data[i], HEX ); 
  //              }
  //          } 
  //          Serial.println();
  
  
            if( s_currentClient )
            {
  //            for( int i = 0; i < param->data_ind.len; i++ ) 
  //            { 
  //                if( param->data_ind.data[i] >= 32 && param->data_ind.data[i] <= 126 )
  //                  s_currentClient->write( (char)param->data_ind.data[i] ); 
  //                else
  //                  s_currentClient->write( param->data_ind.data[i] ); 
  //            } 
  //            s_currentClient->write( '\n' );
                s_currentClient->write( param->data_ind.data, param->data_ind.len );
            }
            break;
          
      case ESP_SPP_CONG_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_CONG_EVT");
          break;
      case ESP_SPP_WRITE_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_WRITE_EVT");
          break;
      case ESP_SPP_SRV_OPEN_EVT:
          ESP_LOGI(SPP_TAG, "ESP_SPP_SRV_OPEN_EVT");
          break;
      default:
          break;
   }
}




void esp_bt_gap_cb( esp_bt_gap_cb_event_t event,  esp_bt_gap_cb_param_t* param ) 
{ 
    switch( event ) 
    { 
      case ESP_BT_GAP_DISC_RES_EVT: 
//        Serial.print( "ESP_BT_GAP_DISC_RES_EVT: num = " ); 
//        Serial.println( param->disc_res.num_prop ); 
        
        for ( int i = 0; i < param->disc_res.num_prop;  i++ ) 
        { 
            if( param->disc_res.prop[i].type == ESP_BT_GAP_DEV_PROP_COD && (memcmp( s_peer_bd_addr, param->disc_res.bda, ESP_BD_ADDR_LEN )  ==  0)  )  
            { 
              Serial.println( "Target device found..." );    
              printStatusMessage( "Target device found" );
    
              esp_spp_start_discovery( s_peer_bd_addr ); 
              esp_bt_gap_cancel_discovery();
            } 
            
            if( param->disc_res.prop[i].type == ESP_BT_GAP_DEV_PROP_COD )  
            { 
              // Class Of Device 
              if( get_name_from_eir( (uint8_t*)(param->disc_res.prop[i].val), s_peer_bdname,  &s_peer_bdname_len )  )  
              { 
                s_peer_bdname[s_peer_bdname_len] = 0; 
                Serial.print( "Device class name: " );              
                Serial.println( s_peer_bdname );              
              } 
            } 
            else if( param->disc_res.prop[i].type == ESP_BT_GAP_DEV_PROP_RSSI ) 
            { 
//              Serial.print( "ESP_BT_GAP_DEV_PROP_RSSI- param->disc_res.prop[i].type: " ); 
//              Serial.println( param->disc_res.prop[i].type ); 
                Serial.println( "O" );
            }
            else if( param->disc_res.prop[i].type == ESP_BT_GAP_DEV_PROP_BDNAME )  
            { 
//              Serial.print( "ESP_BT_GAP_DEV_PROP_BDNAME- param->disc_res.prop[i].type: " ); 
//              Serial.println( param->disc_res.prop[i].type ); 
                Serial.println( "o" );
            } 
            else 
            { 
//              Serial.print( "param->disc_res.prop[i].type: " ); 
//              Serial.println( param->disc_res.prop[i].type ); 
                Serial.println( "." );
            } 
        } 
        break; 
        
    case  ESP_BT_GAP_DISC_STATE_CHANGED_EVT : 
        break ; 
    case  ESP_BT_GAP_RMT_SRVCS_EVT : 
        break ; 
    case  ESP_BT_GAP_RMT_SRVC_REC_EVT : 
        break ; 
    case  ESP_BT_GAP_AUTH_CMPL_EVT :
        break ; 
   
    case  ESP_BT_GAP_PIN_REQ_EVT : 
    { 
        if( param->pin_req.min_16_digit )  
        { 
            esp_bt_pin_code_t  pin_code = { 0 }; 
            esp_bt_gap_pin_reply( param->pin_req.bda, true, 16, pin_code ); 
        }  
        else  
        { 
            esp_bt_pin_code_t  pin_code ; 
            pin_code[0] = '1'; 
            pin_code[1] = '2'; 
            pin_code[2] = '3'; 
            pin_code[3] = '4'; 
            esp_bt_gap_pin_reply( param->pin_req.bda, true, 4, pin_code ); 
        } 
        break ; 
    } 
    case  ESP_BT_GAP_CFM_REQ_EVT : 
        esp_bt_gap_ssp_confirm_reply( param->cfm_req.bda, true ); 
        break ; 
    
    case  ESP_BT_GAP_KEY_NOTIF_EVT : 
        break ; 
    case  ESP_BT_GAP_KEY_REQ_EVT : 
        break ; 
    default:
        break ; 
    } 
}


void printStatusMessage( const char* msg, bool showLogo )
{
    display.clearDisplay();
    if( showLogo )
      display.drawBitmap( 0, 0, s_folabs_logo, 128, 32, 1 );
    
    display.setTextSize( 1 );
    display.setTextColor( WHITE );
    display.setCursor( showLogo ? 42 : 0, (32 - 6) / 2 );
    display.println( msg );
    display.setCursor( 0, 0 );
    display.display(); 
}


void setup() 
{
    pinMode( BUTTON_A, INPUT_PULLUP );
    pinMode( BUTTON_B, INPUT_PULLUP );
    pinMode( BUTTON_C, INPUT_PULLUP );

    // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
    display.begin( SSD1306_SWITCHCAPVCC, 0x3C ); // Address 0x3C for 128x32
  
    Serial.println( "OLED started" );
  
    // Clear the buffer - draw logo and some text for now to test !!@
    printStatusMessage( "Far Out Labs", true );

    delay( 1500 );
    Serial.begin( 115200 );  
    
    printStatusMessage( "Connecting to WiFi" );

    WiFi.mode( WIFI_STA );
    WiFi.begin( ssid, password );

    while( WiFi.status() != WL_CONNECTED ) 
    {
      delay(500);
      Serial.print(".");
    }
    Serial.println("");
    Serial.println( "WiFi done: " );
    Serial.println( WiFi.localIP() );

    if( MDNS.begin( DEVICE_NAME ) ) 
    {
      Serial.println( "mDNS responder started..." );
      MDNS.addService( "kiss", "_tcp", KISS_PORT );

      printStatusMessage( "mDNS started" );
    }

    wifiServer.begin();

    esp_err_t ret = 0;

    // !!@ figure out if btStart() does this or why this is needed !!@
//    esp_err_t ret = nvs_flash_init();
//    if( ret == ESP_ERR_NVS_NO_FREE_PAGES ) 
//    {
//        ESP_ERROR_CHECK( nvs_flash_erase() );
//        ret = nvs_flash_init();
//    }
//    ESP_ERROR_CHECK( ret );


    if( !btStart() )
    {
        ESP_LOGE(SPP_TAG, "%s btStart failed\n", __func__ );
        return;
    }
      
    esp_bluedroid_status_t bt_state = esp_bluedroid_get_status(); 
    if( bt_state == ESP_BLUEDROID_STATUS_UNINITIALIZED ) 
    { 
        if ( esp_bluedroid_init() )  
        { 
            Serial.println( "Bluedroid init failed..." ); 
            printStatusMessage( "Bluedroid failed" );
            return; 
        } 
    }

    if( bt_state != ESP_BLUEDROID_STATUS_ENABLED ) 
    { 
        if( esp_bluedroid_enable() )  
        { 
            Serial.println( "Bluedroid enable failed..." ); 
            printStatusMessage( "Bluedroid en failed" );
            return; 
        } 
    }

    ret = esp_bt_gap_register_callback( esp_bt_gap_cb );
    if( ret !=  ESP_OK ) 
        return; 

    ret = esp_spp_register_callback( esp_spp_cb );
    if( ret != ESP_OK )
        return; 
    
    ret = esp_spp_init( esp_spp_mode );
    if( ret != ESP_OK ) 
        return; 
 
    // Set Default Parameters For Secure Simple Pairing
    esp_bt_sp_param_t  param_type = ESP_BT_SP_IOCAP_MODE; 
    esp_bt_io_cap_t    Iocap      = ESP_BT_IO_CAP_IO; 
    esp_bt_gap_set_security_param( param_type, &Iocap, sizeof( uint8_t ) );

    // Set default parameters for Legacy Pairing -- use variable pin, input pin code when pairing
    esp_bt_pin_type_t  pin_type = ESP_BT_PIN_TYPE_VARIABLE; 
    esp_bt_pin_code_t  pin_code; 
    esp_bt_gap_set_pin( pin_type,  0, pin_code );

    Serial.println( "Bluetooth init complete" );
    printStatusMessage( "Bluetooth inited" );

    delay( 1200 );

    display.clearDisplay();
    display.drawBitmap( 0, 0, s_folabs_logo, 128, 32, 1 );
    
    display.setTextSize( 1 );
    display.setTextColor( WHITE );
    display.setCursor( 42, (32 - 9) / 2 );
    display.println( DEVICE_NAME );
    display.setCursor( 42, (32 - 9) );
    display.println( WiFi.localIP() );
    display.display(); 

//    char buffer[128];
//    sprintf( buffer, "%s\n%s", DEVICE_NAME, WiFi.localIP().toString().c_str() );
//    printStatusMessage( buffer );
}


void loop() 
{
    WiFiClient client = wifiServer.available();
   
    if( client )
    {
        Serial.println( "Client connected..." );
        printStatusMessage( "Client connected" );
        s_currentClient = &client;
        
        while( client.connected() ) 
        {
            while( client.available() > 0 ) 
                client.write( (char)client.read() );
       
            delay( 10 );
        }

        s_currentClient = NULL;
        client.stop();
        Serial.println( "Client disconnected..." );
    }
}
